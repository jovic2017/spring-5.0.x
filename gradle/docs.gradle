/*
 * Copyright 2002-2017 the original author or authors.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */



//task docsZip(type: Zip, dependsOn: []) {
//	group = "Distribution"
//	baseName = "spring-framework"
//	classifier = "docs"
//	description = "Builds -${classifier} archive containing api and reference " +
//			"for deployment at https://docs.spring.io/spring-framework/docs."
//
//	from("src/dist") {
//		include "changelog.txt"
//	}
//
////	from ("$asciidoctor.outputDir/html5") {
////		into "spring-framework-reference"
////	}
////
////	from ("$asciidoctor.outputDir/pdf") {
////		into "spring-framework-reference/pdf"
////	}
//
//}

//task schemaZip(type: Zip) {
//	group = "Distribution"
//	baseName = "spring-framework"
//	classifier = "schema"
//	description = "Builds -${classifier} archive containing all " +
//			"XSDs for deployment at https://springframework.org/schema."
//	duplicatesStrategy 'exclude'
//	moduleProjects.each { subproject ->
//		def Properties schemas = new Properties();
//
//		subproject.sourceSets.main.resources.find {
//			it.path.endsWith("META-INF/spring.schemas")
//		}?.withInputStream { schemas.load(it) }
//
//		for (def key : schemas.keySet()) {
//			def shortName = key.replaceAll(/http.*schema.(.*).spring-.*/, '$1')
//			assert shortName != key
//			File xsdFile = subproject.sourceSets.main.resources.find {
//				it.path.endsWith(schemas.get(key))
//				//window下面编译要处理一下路径问题,上面一句要用下面这句替换
//				//it.path.endsWith(schemas.get(key).replaeAll('\\/','\\\\'))
//			}
//			assert xsdFile != null
//			into (shortName) {
//				from xsdFile.path
//			}
//		}
//	}
//}

//task distZip(type: Zip, dependsOn: [docsZip, schemaZip]) {
//
//	group = "Distribution"
//	baseName = "spring-framework"
//	classifier = "dist"
//	description = "Builds -${classifier} archive, containing all jars and docs, " +
//			"suitable for community download page."
//
//	ext.baseDir = "${baseName}-${project.version}";
//
//	from("src/docs/dist") {
//		include "readme.txt"
//		include "license.txt"
//		include "notice.txt"
//		into "${baseDir}"
//		expand(copyright: new Date().format("yyyy"), version: project.version)
//	}
//
//	from(zipTree(docsZip.archivePath)) {
//		into "${baseDir}/docs"
//	}
//
//	from(zipTree(schemaZip.archivePath)) {
//		into "${baseDir}/schema"
//	}
//
//	moduleProjects.each { subproject ->
//		into ("${baseDir}/libs") {
//			from subproject.jar
//			if (subproject.tasks.findByPath("sourcesJar")) {
//				from subproject.sourcesJar
//			}
//			if (subproject.tasks.findByPath("javadocJar")) {
//				from subproject.javadocJar
//			}
//		}
//	}
//}
//
//distZip.mustRunAfter subprojects.test

// Create a distribution that contains all dependencies (required and optional).
// Not published by default; only for use when building from source.
//task depsZip(type: Zip, dependsOn: distZip) { zipTask ->
//	group = "Distribution"
//	baseName = "spring-framework"
//	classifier = "dist-with-deps"
//	description = "Builds -${classifier} archive, containing everything " +
//			"in the -${distZip.classifier} archive plus all runtime dependencies."
//
//	from zipTree(distZip.archivePath)
//
//	gradle.taskGraph.whenReady { taskGraph ->
//		if (taskGraph.hasTask(":${zipTask.name}")) {
//			def projectNames = rootProject.subprojects*.name
//			def artifacts = new HashSet()
//			subprojects.each { subproject ->
//				(subproject.configurations.runtime.resolvedConfiguration.resolvedArtifacts +
//						subproject.configurations.optional.resolvedConfiguration.resolvedArtifacts).each { artifact ->
//					def dependency = artifact.moduleVersion.id
//					if (!projectNames.contains(dependency.name)) {
//						artifacts << artifact.file
//					}
//				}
//			}
//
//			zipTask.from(artifacts) {
//				into "${distZip.baseDir}/deps"
//			}
//		}
//	}
//}
